#---------------
# ICDB Selections File Algebra
#
# this is a tool to allow interactive 'set arithmetic' on ICDB save files (as generated by the ICDB)
#	operations supported are:
#	- add
#	- remove
#	- intersect
#	- clear
#	- single entry (manually add 1 value)
#	- save
#	- quit
#
#	(this is also my first foray in the Tkinter package... ugh)
#
# 2017-03-13
#	release this to 'production' via the N:\nwic-gis\nwic_gis_tools directory
#
#	yet to come:
#		delete entries from the current list by selecting them in the list and clicking 'remove' (better name)
# 2017-03-30
#	need to be able to 'Add' multiple files at once; i.e. select multiple files from the tkFileDialog.askopenfilename dialog
#
# 2018_03-29:
#	got the <Enter> key to do an 'add_single' and clear the input box
#	implemented a 'save log' button


import Tkinter
import ttk
import ScrolledText
import tkFileDialog
import openpyxl
import re

sheet_saved_resources		= "tblResSelect"
sheet_saved_reports			= "tblInvSelect"

current_list 		= []			# initialize an empty list
current_list_type	= None			# the current list is neither reports nor resources

work_list			= []			# the list loaded from 'add', 'remove', or 'intersect'
work_list_type		= None
work_list_error		= None			# any error message from trying to load the worksheet


#----------------
# update_list()
#	a helper function used across many of the buttton function to update display of the current list
#	redraw the current list shown in the 'show_list' window
#	this includes formatting the current list into S-#'s or P-#'s according to current_list_type

def update_list():
	global current_list
	global current_list_type
	
	if current_list_type == 'reports':
		show_list.delete('1.0','end')
		current_list.sort()
		show_list.insert('end','\n'.join(["S-{0:06}".format(x) for x in current_list]))
	elif current_list_type == 'resources':
		show_list.delete('1.0','end')
		current_list.sort()
		show_list.insert('end','\n'.join(["P-{0}".format(x) for x in current_list]))
	else:
		show_list.delete('1.0','end')

#----------
# load_work_list()
#	takes a filename (hopefully of a ICDB saved selections file)
#	and loads it up into the work_list global, setting the work_list_type
#	if any error occurs, set a string for the error in work_list_error

def load_work_list(f_name):
	global work_list
	global work_list_type
	global work_list_error
	work_list = []
	work_list_type = None
	work_list_error = None

	wb = openpyxl.load_workbook(str(f_name))
	for sheet in wb.get_sheet_names():
		if sheet == sheet_saved_reports or sheet == sheet_saved_resources:
			break

	if sheet == sheet_saved_reports:
		tbl_Reports = wb[sheet]
		if tbl_Reports.cell(column=2, row=1).value != "DocNo" or tbl_Reports.cell(column=1,row=1).value != "DocCo":
			work_list_error = "File is not a valid ICDB saved reports"
			del wb
			return
		work_list_type = 'reports'
		cellrow = 2			# start reading at row 2 of column 'B'
		while cellrow > 0:
			ws_cell = tbl_Reports.cell(column=2, row=cellrow)
			if ws_cell.value is not None:
				work_list.append(ws_cell.value)							# add the S-# to the DocList
				cellrow += 1
			else:
				cellrow = 0												# end of the list
				del wb
				return
		
	elif sheet == sheet_saved_resources:
		tbl_Resources = wb[sheet]
		if tbl_Resources.cell(column=2,row=1).value != "PrimNo" or tbl_Resources.cell(column=1,row=1).value != "PrimCo":
			work_list_error = "File is not a valid ICDB saved resources"
			return
		work_list_type = 'resources'
		cellrow = 2
		while cellrow > 0:
			cellCo = tbl_Resources.cell(column=1,row=cellrow)
			cellNo = tbl_Resources.cell(column=2,row=cellrow)
			if cellCo.value is not None and cellNo.value is not None:
				work_list.append("{0:02}-{1:06}".format(cellCo.value,cellNo.value))
				cellrow += 1
			else:
				cellrow = 0
				del wb
				return
	
	else:
		work_list_error = "File is not a valid ICDB saved selections"
		del wb

#--------------------------
# save_current_list()
#	given a filename, write out the contents of the current_list
#	in a format suitable for loading into the ICDB as a saved selections
#	uses the current_list_type to determine the particular layout (report or resources)

def save_current_list(f_name):
	global current_list
	global current_list_type

	wb = openpyxl.Workbook()
	ws = wb.active
	if current_list_type == 'reports':
		ws.title = "tblInvSelect"
		ws.cell(column=1,row=1,value='DocCo')
		ws.cell(column=2,row=1,value='DocNo')
		ws.cell(column=3,row=1,value='ItemSelected')
		ws.cell(column=4,row=1,value='ItemReselected')
		cellrow = 2
		for s in current_list:
			ws.cell(column=1,row=cellrow,value=0)
			ws.cell(column=2,row=cellrow,value=s)
			ws.cell(column=3,row=cellrow,value=True)
			ws.cell(column=4,row=cellrow,value=False)
			cellrow += 1
		wb.save(f_name)
		return			
		

	if current_list_type == 'resources':
		ws.title = "tblResSelect"
		ws.cell(column=1,row=1,value='PrimCo')
		ws.cell(column=2,row=1,value='PrimNo')
		ws.cell(column=3,row=1,value='PNumber')
		ws.cell(column=4,row=1,value='ItemSelected')
		ws.cell(column=5,row=1,value='ItemReselected')
		cellrow = 2
		for p in current_list:
			(PrimCo,PrimNo) = (int(x) for x in p.split('-'))
			ws.cell(column=1,row=cellrow,value=PrimCo)
			ws.cell(column=2,row=cellrow,value=PrimNo)
			ws.cell(column=4,row=cellrow,value=True)
			ws.cell(column=5,row=cellrow,value=False)
			cellrow += 1
		wb.save(f_name)
		return			

#---------------------------
#	BUTTON functions
#---------------------------

#---------------------------
# set_add()
#	tosses up the askopenfilenames dialog box to allow user to select 1 or more filenames
#	then loops through the list of returned filenames and performs an 'add' operation on each one to the current list
#	the looping stops if there is an error

def set_add():
	global work_list
	global work_list_type
	global work_list_error
	global current_list
	global current_list_type
	
	filenames = tkFileDialog.askopenfilenames(parent=root,defaultextension='.xlsx',filetypes=[('Excel files','.xlsx')],title="Add from ...")
	for filename in filenames:
		if len(filename) > 0:
			log.insert(Tkinter.END,"Add:       {0}\n".format(filename))
			load_work_list(filename)
		else:
			return								# this is a quiet 'ignore' if user selects no files (e.g. clicks 'cancel')
		# if load_work_list had a problem, a message is left in work_list_error
		if work_list_error:
			log.insert(Tkinter.END,"   {0}\n".format(work_list_error))
			log.see('end')
			return
		if (work_list_type != current_list_type) and (current_list_type != None):
			log.insert(Tkinter.END,"   Cannot add a list of {0} to a list of {1}\n".format(work_list_type,current_list_type))
			log.see('end')
			return
		prior_len = len(current_list)
		current_list = list(set(current_list) | set(work_list))				# | = the union operator
		current_list_type = work_list_type
		new_len = len(current_list)
		log.insert(Tkinter.END,"   Added {0} new entries to the list\n".format(new_len - prior_len))
		log.see('end')
		cur_count.set(len(current_list))
		update_list()
	

#---------------------------
# set_remove()
#	ask the user to select an existing selections list excel file (or files)
#	then, remove any selections in the current list that are in the user's selected list(s)

def set_remove():
	global work_list
	global work_list_type
	global work_list_error
	global current_list
	global current_list_type
	
	filenames = tkFileDialog.askopenfilenames(parent=root,defaultextension='.xlsx',filetypes=[('Excel files','.xlsx')],title="Remove those in ...")
	for filename in filenames:
		if len(filename) > 0:
			log.insert(Tkinter.END,"Remove:    {0}\n".format(filename))
			load_work_list(filename)
		else:
			return
		if work_list_error:
			log.insert(Tkinter.END,"  {0}\n".format(work_list_error))
			log.see('end')
			return
		if (work_list_type != current_list_type) and (current_list_type != None):
			log.insert(Tkinter.END,"Cannot remove a list of {0} from a list of {1}\n".format(work_list_type,current_list_type))
			log.see('end')
			return
		
		prior_len = len(current_list)
		current_list = list(set(current_list) - set(work_list))				# - = the difference operator
		new_len = len(current_list)
		if new_len > 0:
			current_list_type = work_list_type
		else:
			current_list_type = None
		log.insert(Tkinter.END,"   Removed {0} entries from the list\n".format(prior_len - new_len))
		cur_count.set(len(current_list))
		update_list()

#---------------------------
# set_intersect()
#	ask the user to select an existing selections list excel file (or files)
#	then depending if there are existing selections in the current list or not...
#		if there are selections in the current list,
#			then remove entries from the current list that are not in the user's selected list(s)
#		if there are no selections in the current list,
#			then assume that the user wants the intersection of a set of selection lists, by the following:
#			add the first user selected list
#			then for selected lists (2 thru N)
#				perform the above removal processed
#			resulting in the current list being constructed as the intersection of all the user's selected lists

def set_intersect():
	global work_list
	global work_list_type
	global work_list_error
	global current_list
	global current_list_type
	
	filenames = tkFileDialog.askopenfilenames(parent=root,defaultextension='.xlsx',filetypes=[('Excel files','.xlsx')],title="Intersect with ....")
	for filename in filenames:
		if len(filename) > 0:
			log.insert(Tkinter.END,"Intersect: {0}\n".format(filename))
			load_work_list(filename)
		else:
			return
		if work_list_error:
			log.insert(Tkinter.END,"  {0}\n".format(work_list_error))
			log.see('end')
			return
		if (work_list_type != current_list_type) and (current_list_type != None):
			log.insert(Tkinter.END,"Cannot intersect a list of {0} with a list of {1}\n".format(work_list_type,current_list_type))
			log.see('end')
			return
		
		prior_len = len(current_list)
		current_list = list(set(current_list) & set(work_list))				# & = intersect operator
		new_len = len(current_list)
		if new_len > 0:
			current_list_type = work_list_type
		else:
			current_list_type = None
		log.insert(Tkinter.END,"   {0} entries removed from the list\n".format(prior_len - new_len))
		cur_count.set(len(current_list))
		update_list()


#---------------------------
# set_clear()
#	simply clear all entries in the current list

def set_clear():
	global current_list
	global current_list_type
	
	current_list = []
	current_list_type = None
	log.insert(Tkinter.END,"Cleared current list of selections\n")
	log.see('end')
	cur_count.set(len(current_list))
	update_list()
	
#---------------------------
# set_save()
#	prompts user (using asksaveasfilename) for an output file
#	then calls save_current_list() to create and write out the ICDB selections for that

def	set_save():
	global current_list
	global current_list_type

	filename = tkFileDialog.asksaveasfilename(parent=root,defaultextension='.xlsx',filetypes=[('Excel files','.xlsx')],title="Save current set as...")
	if len(filename) > 0:
		log.insert(Tkinter.END,"Save to: {0}\n".format(filename))
		log.see('end')
		save_current_list(filename)
	else:
		return

#---------------------
# log_save()
#	save the text of the log window
def log_save():
	filename = tkFileDialog.asksaveasfilename(parent=root,defaultextension='.txt',filetypes=[('Text files','.txt')],title="Save the activity log as...")
	if len(filename) > 0:
		log.insert(Tkinter.END,"Save log to: {0}\n".format(filename))
		log.see('end')
		log_f = open(filename,"w")
		log_f.write(log.get('1.0',Tkinter.END))
		log_f.close()
		del log_f
	else:
		return
	
#---------------------
# add_single()
#	takes the string value in 'single' variable
#	tries to recognize it as either an S-# or a P-#
#	creates a 1-entry work_list for that
#	and then does an 'add' operation to add it to the current_list

def add_single():
	global work_list
	global work_list_type
	global work_list_error
	global current_list
	global current_list_type

	work_list_type = None
	work_list = []
	
	candidate = single.get().strip()
	match_s = re.match("^([Ss]-)?(\d{1,6})$",candidate)
	if match_s:
		work_list = [int(match_s.groups()[1])]
		work_list_type = 'reports'
		candidate_format = "S-{0:06}".format(work_list[0])

	match_p = re.match("([pP]-)?(\d{1,2})-(\d{1,6})",candidate)
	if match_p:
		(p_co, p_no) = (int(match_p.groups()[1]),int(match_p.groups()[2]))
		work_list = ["{0:02}-{1:06}".format(p_co,p_no)]
		work_list_type = 'resources'
		candidate_format = "P-{0}".format(work_list[0])
		
	if len(work_list) > 0:
		if (work_list_type != current_list_type) and (current_list_type != None):
			log.insert(Tkinter.END,"Cannot add a {0} to a list of {1}\n".format(work_list_type,current_list_type))
			log.see('end')
		else:
			if work_list[0] in current_list:
				log.insert(Tkinter.END,"{0}  already in list\n".format(candidate_format))
			else:
				current_list = list(set(current_list) | set(work_list))				# | = the union operator
				current_list_type = work_list_type
				log.insert(Tkinter.END,"{0}  added\n".format(candidate_format))
			log.see('end')
			cur_count.set(len(current_list))

	update_list()						# refresh the control showing the current list
	single.set("")						# clear the entry
	single_entry.focus()				# put the edit focus back on the input box

#----------------
# manually delete the selected entry/entries in the show_list window
#	this entails ignoring the button click if there is nothing selected
#	or if the selection contains a partial-line, i.e., the column index in the sel.xxx values is non-zero

def del_single():
	global work_list
	global work_list_type
	global work_list_error
	global current_list
	global current_list_type

	try:
		sel_first = show_list.index('sel.first')				# get the l.c value for beginning of selection ('l.c = line.column)
		sel_last = show_list.index('sel.last')					# get the l.c value for the end of the selection
	except:
		return													# if nothing is selected, just ignore the click
	
	(first_line,first_col) = sel_first.split('.')			# now... pull apart the (line,column) start & end points of the selected text
	(last_line,last_col) = sel_last.split('.')
	if first_col != '0':									# if the selected items are not complete lines, ignore the click
		return
	if last_col != '0':
		sel_last_end = show_list.index(last_line+'.end')	# if 'sel.last' != 'sel.end' then ignore click (it's only a partial line select)
		if sel_last_end != sel_last:
			return
		
	del_select = show_list.get('sel.first','sel.last')		# otherwise, get the whole-lines selection
	del_list = del_select.split('\n')						# split up by line separators
	if len(del_list[-1]) < 1:
		del_list = del_list[0:-1]
	log.insert(Tkinter.END,"{0}  deleted\n".format(', '.join(del_list)))
	
	# now, at this point it's pretty much like 'remove'. but the list to remove is in del_list (but it needs to be 'processed' first)
	work_list = []
	work_list_type = current_list_type
	if current_list_type == 'reports':
		for del_item in del_list:
			del_match = re.match("^([Ss]-)?(\d+)$",del_item)
			work_list.append(int(del_match.groups()[1]))
	if current_list_type == 'resources':
		for del_item in del_list:
			del_match = re.match("([pP]-)?(\d{1,2})-(\d{1,6})",del_item)
			(p_co, p_no) = (int(del_match.groups()[1]),int(del_match.groups()[2]))
			work_list.append("{0:02}-{1:06}".format(p_co,p_no))
	
	prior_len = len(current_list)
	current_list = list(set(current_list) - set(work_list))				# - = the difference operator
	new_len = len(current_list)
	if new_len > 0:
		current_list_type = work_list_type
	else:
		current_list_type = None
	single.set("")						# clear the entry
	cur_count.set(len(current_list))
	update_list()
	
#---------------------------
# app_quit()
#	kill the event loop and dismiss the window and exit the app_quit

def app_quit(*args):
	root.destroy()

#---------------------------
#	MAIN 
#---------------------------

root = Tkinter.Tk()
root.title("ICDB Selections Mixer")

mainframe = ttk.Frame(root,padding="5")
mainframe.grid(column=0,row=0,sticky=(Tkinter.W , Tkinter.N, Tkinter.E, Tkinter.S))
mainframe.columnconfigure(0,weight=1)
mainframe.rowconfigure(0,weight=1)

single = Tkinter.StringVar()			# a field to enter a single S# or P#
cur_count = Tkinter.StringVar()			# a string to show the current number of selections in the list


ttk.Button(mainframe, text='Add List', command=set_add).grid(column=2, row=1)					# button to add ICDB saved selections to the current list
ttk.Button(mainframe, text='Remove List', command=set_remove).grid(column=2,row=2)				# button to remove saved selections from the current list
ttk.Button(mainframe, text='Intersect', command=set_intersect).grid(column=2,row=3)				# button to intersect (see function above)
single_entry = ttk.Entry(mainframe,width=11,textvariable=single,font=('Arial','12'))			# the input control box where user types a single S-# or P-#
single_entry.grid(column=2,row=4,sticky=(Tkinter.W,Tkinter.E))
ttk.Button(mainframe, text='Add Single', command=add_single).grid(column=2,row=5)				# button to add the typed in S-# or P-# to the current list
ttk.Button(mainframe, text='Del Selected', command=del_single).grid(column=2,row=6)				# button that deletes from the current list (using selected item in current list)
ttk.Label(mainframe, text="Count").grid(column=2,row=7)											# a label for the next control
ttk.Label(mainframe, textvariable=cur_count).grid(column=2, row=8)								# a control text (output) that shows the number of entries in the current list
ttk.Button(mainframe, text='Clear', command=set_clear).grid(column=2,row=9)						# button to clear the current list of all entries
ttk.Button(mainframe, text='Save Selections', command=set_save).grid(column=3,row=10)			# button to save the current list to an ICDB selections file
ttk.Button(mainframe, text='Quit', command=app_quit).grid(column=4,row=10)						# button to exit the application
ttk.Button(mainframe, text='Save Log', command=log_save).grid(column=5,row=10)					# button to save the text in the log window to a file

#ttk.Label(mainframe,text="is equivalent to").grid(column=1, row=2,sticky=Tkinter.E)
#ttk.Label(mainframe,text="meters").grid(column=3, row=2,sticky=Tkinter.W)

log = ScrolledText.ScrolledText(master=mainframe, width=80, height=30, wrap=Tkinter.WORD)		# this is the log window that shows the activity done in the app
log.grid(column=3, columnspan=3, row=1, rowspan=9, sticky='NEWS')
log.insert(Tkinter.END,"ICDB Selections Mixer - version: 3/29/2018\n")							# stuff in some introductory text into the log
log.insert(Tkinter.END," Add list:    add 1 or more selection lists to the current list\n")
log.insert(Tkinter.END," Remove list: remove selections in 1 or more selection lists from current list\n")
log.insert(Tkinter.END," Intersect:   find selections in 1 or more selection lists that are\n              in all lists and in current list\n")
log.insert(Tkinter.END," Add single:  add the single S-# or P-# entered in box above\n")
log.insert(Tkinter.END," Del selected:remove the selected line(s) from the current list\n")
log.bind("<Key>", lambda e: "break")															# prevent user from typing into the log window

show_list = ScrolledText.ScrolledText(master=mainframe, width=14, height=30)	# a control to display the current list of selections
show_list.grid(column=1, row=1, rowspan=9, sticky='NEWS')
show_list.bind("<Key>", lambda e: "break")										# prevent user from typing into the list (but allows selecting text)

cur_count.set(len(current_list))												# initialize the display of the number of entries in the current list

for child in mainframe.winfo_children():										# go through each of the controls and spread them out from each other
	child.grid_configure(padx=3, pady=3)

single_entry.focus()															# jump the focus to the control where single values are typed in
root.bind('<Return>', (lambda e: add_single()))									# make <Enter> key do an <Add> button action

root.mainloop()																	# all setup, start the event loop to run the app

